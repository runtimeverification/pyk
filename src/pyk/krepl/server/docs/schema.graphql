schema {
  query: Query
  mutation: Mutation
  #  subscription: Subscription  # GraphQL supports subscribing to events. This could be useful for process management.
}

type Query {
  # Model
  graph: Graph!

  # Process management
  processes(id: ProcessID, status: ProcessStatus): [Process!]!
  wait(id: ProcessID!): Process!

  # Presentation
  diff(from: NodeID, to: NodeID): String!
}

type Mutation {
  # Initialization
  load(input: LoadInput!): Graph!
  loadRaw(kore: String!): Graph!

  # Behavior
  step(id: NodeID!, depth: Int, branch: Bool = True, wait: Bool = False): StepProcess!
  rewind(id: NodeID!, depth: Int, wait: Bool = False): RewindProcess!

  # Edit
  updateCell(id: NodeID!, cell: String!, value: TermString!): Node!
}


# Model

scalar NodeID
scalar EdgeID

type Graph {
  init: Node!
  nodes(id: NodeID, tagged: String): [Node!]!
  edges(id: EdgeID, source: NodeID, target: NodeID, tagged: String): [Edge!]!
  tags: [String!]!
  dot: String!
  tree: String!
}

type Node {
  id: NodeID!
  term: Term!
  inEdge: Node
  outEdges: [Node!]!
  tags: [String!]!
}

type Edge {
  id: EdgeID!
  source: Node!
  target: Node!
  condition: Term!
  substitution: Subst!
}

type Term {
  pretty(cells: [String!]): String
  kast: String
  kastJSON: JSONString
  kore: String
  koreJSON: JSONString
}


# Process handling

scalar ProcessID

enum ProcessStatus {
  PENDING
  RUNNING
  DONE
}

interface Process {
  id: ProcessID!
  status: ProcessStatus!
}

type StepProcess implements Process {
  id: ProcessID!
  status: ProcessStatus!
  result: StepResult
}

type RewindProcess implements Process {
  id: ProcessID!
  status: ProcessStatus!
  result: RewindResult
}


# Initialization

input LoadInput {
  program: TermString
  params: [LoadParam!]
}

input TermString {
  term: String!
  module: String
  sort: String
}

input LoadParam {
  name: String!
  program: TermString
}


# Behavior

interface Result {
  graph: Graph!
}

type StepResult implements Result {
  graph: Graph!
  newNodes: [Node!]!
  newEdges: [Edge!]!
}

type RewindResult implements Result {
  graph: Graph!
  newNode: Node
  newEdges: [Edge!]!
  removedEdges: [Edge!]!
}
